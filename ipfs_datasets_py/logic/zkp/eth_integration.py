"""
Phase 3C.6: Ethereum On-Chain Integration

This module provides Python integration for submitting Groth16 proofs
to Ethereum smart contracts for on-chain verification.

Architecture:
  - EthereumProofClient: High-level interface
  - ProofSubmissionPipeline: Orchestrate generation → submission → verification
  - GasEstimator: Predict and optimize transaction costs
  - TransactionMonitor: Track confirmation and finality
"""

import json
import time
import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
from decimal import Decimal

from .eth_vk_registry_payloads import build_register_vk_payload

import web3
from web3 import Web3
from web3.contract import Contract
from web3.eth import Eth
from web3.types import Address, TxHash, BlockIdentifier


logger = logging.getLogger(__name__)


@dataclass
class EthereumConfig:
    """Configuration for Ethereum network connection."""
    rpc_url: str                           # RPC endpoint (e.g., Infura, Alchemy, Sepolia)
    network_id: int                        # Chain ID (1=mainnet, 11155111=sepolia)
    network_name: str                      # Human-readable name (mainnet, sepolia, etc.)
    verifier_contract_address: str         # Deployed GrothVerifier contract
    registry_contract_address: str         # Deployed ComplaintRegistry contract
    vk_hash_registry_contract_address: Optional[str] = None  # VKHashRegistry (bytes32 circuitId → vkHash)
    confirmation_blocks: int = 20          # Blocks to wait for finality
    gas_price_multiplier: float = 1.2     # Multiply base gas price by this factor
    
    @classmethod
    def from_dict(cls, config_dict: dict) -> 'EthereumConfig':
        return cls(**config_dict)


@dataclass
class ProofVerificationResult:
    """Result of on-chain proof verification."""
    transaction_hash: str
    block_number: int
    block_timestamp: int
    verified: bool
    gas_used: int
    gas_price: int
    transaction_fee: float                 # in ETH
    confirmation_blocks: int
    proof_id: int                          # Registry ID of stored proof


@dataclass
class GasEstimate:
    """Gas cost estimation for proof submission."""
    execution_gas: int                     # Gas for verification computation
    calldata_gas: int                      # Gas for proof data in transaction
    overhead_gas: int                      # Fixed overhead (storage, logging)
    total_gas: int                         # Total estimated gas
    base_fee: float                        # Wei per gas (base)
    estimated_fee_eth: float               # Total estimated cost in ETH
    recommended_gas_price: float           # Wei per gas (with multiplier)


class EthereumProofClient:
    """
    High-level client for on-chain proof verification.
    
    Usage:
        client = EthereumProofClient(config)
        result = client.verify_proof_onchain(proof_json, witness_hex)
    """
    
    def __init__(self, config: EthereumConfig):
        """Initialize Ethereum client."""
        self.config = config
        self.w3 = Web3(Web3.HTTPProvider(config.rpc_url))
        
        if not self.w3.is_connected():
            raise ConnectionError(f"Failed to connect to {config.rpc_url}")
        
        logger.info(f"Connected to {config.network_name}: {self.w3.eth.chain_id}")
        
        # Load contract ABIs (would be generated by solc)
        self.verifier_contract = self._load_contract(
            config.verifier_contract_address,
            "GrothVerifier"
        )
        self.registry_contract = self._load_contract(
            config.registry_contract_address,
            "ComplaintRegistry"
        )

        self.vk_hash_registry_contract: Optional[Contract] = None
        if getattr(config, "vk_hash_registry_contract_address", None):
            self.vk_hash_registry_contract = self._load_contract(
                config.vk_hash_registry_contract_address,
                "VKHashRegistry",
            )
    
    def _load_contract(self, address: str, contract_name: str) -> Contract:
        """Load contract instance with ABI."""
        # For now, return a basic contract interface
        # In production, would load actual ABI from compiled contracts
        abi = self._get_contract_abi(contract_name)
        return self.w3.eth.contract(
            address=Web3.to_checksum_address(address),
            abi=abi
        )
    
    def _get_contract_abi(self, contract_name: str) -> List[Dict]:
        """Get contract ABI by name."""
        if contract_name == "GrothVerifier":
            return GROTH_VERIFIER_ABI
        elif contract_name == "ComplaintRegistry":
            return COMPLAINT_REGISTRY_ABI
        else:
            raise ValueError(f"Unknown contract: {contract_name}")

    def register_vk_hash(
        self,
        circuit_id: str,
        version: int,
        vk_hash_hex: str,
        *,
        overwrite: bool = False,
        from_account: Address,
        private_key: str,
        gas_price_wei: Optional[int] = None,
        gas: int = 250_000,
    ) -> TxHash:
        """Register a verifying-key hash in VKHashRegistry.

        `circuit_id` may be a 0x-prefixed bytes32 hex string or a text
        identifier (hashed via keccak256). `vk_hash_hex` may be a 64-hex
        digest (with/without 0x) or a bytes32 hex string.
        """
        if self.vk_hash_registry_contract is None:
            raise ValueError("VKHashRegistry contract is not configured")

        if not isinstance(circuit_id, str) or circuit_id.strip() == "":
            raise TypeError("circuit_id must be a non-empty str")

        circuit_id_s = circuit_id.strip()
        if circuit_id_s.lower().startswith("0x"):
            circuit_id_bytes32 = circuit_id_s
        else:
            circuit_id_bytes32 = "0x" + Web3.keccak(text=circuit_id_s).hex()

        payload = build_register_vk_payload(
            circuit_id_bytes32=circuit_id_bytes32,
            version=int(version),
            vk_hash_hex=vk_hash_hex,
        )

        tx = self.vk_hash_registry_contract.functions.registerVK(
            payload.circuit_id_bytes32,
            int(payload.version),
            payload.vk_hash_bytes32,
            bool(overwrite),
        ).build_transaction({
            "from": from_account,
            "nonce": self.w3.eth.get_transaction_count(from_account),
            "gasPrice": gas_price_wei or int(self.w3.eth.gas_price * self.config.gas_price_multiplier),
            "gas": gas,
        })

        signed_tx = self.w3.eth.account.sign_transaction(tx, private_key)
        return self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
    
    def estimate_verification_cost(self, proof_data: bytes) -> GasEstimate:
        """Estimate gas and ETH cost for proof verification."""
        # Parse proof (8 uint256 values = 256 bytes)
        calldata_bytes = 4 + (8 * 32) + (4 * 32)  # Function selector + proof + public inputs
        
        # Gas estimation based on measured data
        execution_gas = 195000  # Base verification cost
        calldata_gas = calldata_bytes * 16  # 16 gas per non-zero byte
        overhead_gas = 20000  # Storage + logs
        total_gas = execution_gas + calldata_gas + overhead_gas
        
        # Get current gas price
        base_fee = float(self.w3.eth.gas_price)
        recommended_gas_price = base_fee * self.config.gas_price_multiplier
        
        fee_wei = total_gas * recommended_gas_price
        fee_eth = Web3.from_wei(fee_wei, 'ether')
        
        return GasEstimate(
            execution_gas=execution_gas,
            calldata_gas=calldata_gas,
            overhead_gas=overhead_gas,
            total_gas=total_gas,
            base_fee=base_fee,
            estimated_fee_eth=float(fee_eth),
            recommended_gas_price=recommended_gas_price
        )
    
    def prepare_proof_for_submission(
        self,
        proof_hex: str,
        public_inputs_hex: List[str]
    ) -> Tuple[List[int], List[int]]:
        """
        Prepare proof and public inputs for contract call.
        
        Args:
            proof_hex: Concatenated hex string of A, B, C components (8 uint256 values)
            public_inputs_hex: List of 4 hex strings (theorem_hash, axioms_commitment, version, ruleset)
        
        Returns:
            (proof_array, inputs_array) - Ready for contract function call
        """
        # Parse proof (8 field elements)
        proof_array = [
            int(proof_hex[i:i+64], 16) for i in range(0, 512, 64)
        ]
        
        # Parse public inputs (4 field elements)
        inputs_array = [
            int(inp, 16) if inp.startswith('0x') else int(inp, 16)
            for inp in public_inputs_hex
        ]
        
        return proof_array, inputs_array
    
    def verify_proof_rpc_call(
        self,
        proof_hex: str,
        public_inputs_hex: List[str]
    ) -> bool:
        """
        Perform off-chain verification via RPC call (no gas cost).
        
        Calls verifyProof as a view function to check result before submission.
        """
        try:
            proof_array, inputs_array = self.prepare_proof_for_submission(
                proof_hex,
                public_inputs_hex
            )
            
            result = self.verifier_contract.functions.verifyProof(
                proof_array,
                inputs_array
            ).call()
            
            return bool(result)
        except Exception as e:
            logger.error(f"RPC verification failed: {e}")
            return False
    
    def submit_proof_transaction(
        self,
        proof_hex: str,
        public_inputs_hex: List[str],
        from_account: Address,
        private_key: str,
        gas_price_wei: Optional[int] = None
    ) -> TxHash:
        """
        Submit proof verification transaction to blockchain.
        
        Args:
            proof_hex: Proof data as hex string
            public_inputs_hex: Public inputs as hex strings
            from_account: Sender address
            private_key: Private key for signing
            gas_price_wei: Gas price (if None, uses estimated)
        
        Returns:
            Transaction hash
        """
        proof_array, inputs_array = self.prepare_proof_for_submission(
            proof_hex,
            public_inputs_hex
        )
        
        # Build transaction
        tx = self.verifier_contract.functions.verifyProof(
            proof_array,
            inputs_array
        ).build_transaction({
            'from': from_account,
            'nonce': self.w3.eth.get_transaction_count(from_account),
            'gasPrice': gas_price_wei or int(self.w3.eth.gas_price * 1.2),
            'gas': 300000,  # Estimate (contract will refund unused)
        })
        
        # Sign transaction
        signed_tx = self.w3.eth.account.sign_transaction(tx, private_key)
        
        # Submit
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        logger.info(f"Submitted proof verification: {tx_hash.hex()}")
        
        return tx_hash
    
    def wait_for_confirmation(
        self,
        tx_hash: TxHash,
        timeout_seconds: int = 300
    ) -> Dict:
        """
        Wait for transaction confirmation.
        
        Args:
            tx_hash: Transaction hash to monitor
            timeout_seconds: Maximum seconds to wait
        
        Returns:
            Receipt dictionary with gas_used, block_number, etc.
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout_seconds:
            try:
                receipt = self.w3.eth.get_transaction_receipt(tx_hash)
                if receipt:
                    return receipt
            except web3.exceptions.BlockNotFound:
                pass
            
            time.sleep(5)  # Check every 5 seconds
        
        raise TimeoutError(f"Transaction {tx_hash.hex()} not confirmed after {timeout_seconds}s")
    
    def wait_for_finality(
        self,
        tx_hash: TxHash,
        receipt: Dict
    ) -> bool:
        """
        Wait until transaction has reached finality (enough confirmations).
        
        Args:
            tx_hash: Transaction hash
            receipt: Transaction receipt
        
        Returns:
            True when sufficient confirmations reached
        """
        tx_block = receipt['blockNumber']
        current_block = self.w3.eth.block_number
        
        while current_block - tx_block < self.config.confirmation_blocks:
            time.sleep(12)  # Ethereum block time
            current_block = self.w3.eth.block_number
            logger.info(f"Tx confirmations: {current_block - tx_block}")
        
        return True


class ProofSubmissionPipeline:
    """
    Orchestrates complete workflow: generate proof → estimate gas → submit → verify.
    
    Usage:
        pipeline = ProofSubmissionPipeline(eth_config, groth16_backend)
        result = pipeline.generate_and_verify_proof(witness_json)
    """
    
    def __init__(
        self,
        eth_config: EthereumConfig,
        groth16_backend
    ):
        """Initialize pipeline."""
        self.eth_client = EthereumProofClient(eth_config)
        self.groth16_backend = groth16_backend
        self.config = eth_config
    
    def generate_and_verify_proof(
        self,
        witness_json: str,
        from_account: Address,
        private_key: str,
        dry_run: bool = False
    ) -> ProofVerificationResult:
        """
        Complete workflow: generate proof and verify on-chain.
        
        Args:
            witness_json: Witness data as JSON string
            from_account: Account submitting proof
            private_key: Private key for signing
            dry_run: If True, skip actual blockchain submission
        
        Returns:
            Verification result
        """
        logger.info("=== Phase 3C.6: On-Chain Proof Verification ===")
        
        # Step 1: Generate proof locally
        logger.info("Step 1: Generating proof locally")
        proof_json = self.groth16_backend.generate_proof(witness_json)
        logger.info(f"Proof generated: {len(proof_json)} bytes")
        
        # Parse proof output
        proof_obj = json.loads(proof_json) if isinstance(proof_json, str) else proof_json
        
        # Step 2: Estimate gas cost
        logger.info("Step 2: Estimating gas cost")
        proof_hex = proof_obj.get('proof_data', '')  # From Rust backend
        gas_estimate = self.eth_client.estimate_verification_cost(bytes.fromhex(proof_hex))
        logger.info(f"Estimated cost: {gas_estimate.estimated_fee_eth} ETH")
        
        # Step 3: Verify off-chain (RPC call)
        logger.info("Step 3: Verifying off-chain (RPC call)")
        public_inputs = [
            proof_obj['public_inputs']['theorem_hash'],
            proof_obj['public_inputs']['axioms_commitment'],
            str(proof_obj['public_inputs']['circuit_version']),
            proof_obj['public_inputs']['ruleset_id']
        ]
        
        rpc_result = self.eth_client.verify_proof_rpc_call(proof_hex, public_inputs)
        logger.info(f"RPC verification result: {rpc_result}")
        
        if not rpc_result:
            logger.warning("Proof failed RPC verification - will not submit to blockchain")
        
        # Step 4: Submit to blockchain (if not dry run)
        if dry_run or not rpc_result:
            logger.info("Dry run or verification failed - skipping blockchain submission")
            return ProofVerificationResult(
                transaction_hash="0x" + "0" * 64,
                block_number=0,
                block_timestamp=0,
                verified=False,
                gas_used=0,
                gas_price=0,
                transaction_fee=0.0,
                confirmation_blocks=0,
                proof_id=0
            )
        
        logger.info("Step 4: Submitting to blockchain")
        tx_hash = self.eth_client.submit_proof_transaction(
            proof_hex,
            public_inputs,
            from_account,
            private_key,
            gas_price_wei=int(gas_estimate.recommended_gas_price)
        )
        
        # Step 5: Wait for confirmation
        logger.info("Step 5: Waiting for confirmation")
        receipt = self.eth_client.wait_for_confirmation(tx_hash)
        logger.info(f"Confirmed in block {receipt['blockNumber']}")
        logger.info(f"Gas used: {receipt['gasUsed']}")
        
        # Step 6: Wait for finality
        logger.info("Step 6: Waiting for finality")
        self.eth_client.wait_for_finality(tx_hash, receipt)
        logger.info("Transaction reached finality")
        
        # Return result
        block_timestamp = self.eth_client.w3.eth.get_block(receipt['blockNumber']).timestamp
        transaction_fee_eth = float(Web3.from_wei(
            receipt['gasUsed'] * gas_estimate.base_fee,
            'ether'
        ))
        
        return ProofVerificationResult(
            transaction_hash=tx_hash.hex(),
            block_number=receipt['blockNumber'],
            block_timestamp=block_timestamp,
            verified=receipt['status'] == 1,
            gas_used=receipt['gasUsed'],
            gas_price=int(gas_estimate.base_fee),
            transaction_fee=transaction_fee_eth,
            confirmation_blocks=self.eth_client.w3.eth.block_number - receipt['blockNumber'],
            proof_id=0  # Would be returned from registry contract
        )


# Contract ABIs (simplified for MVP - would be generated by solc)
GROTH_VERIFIER_ABI = [
    {
        "name": "verifyProof",
        "type": "function",
        "inputs": [
            {"name": "proof", "type": "uint256[8]"},
            {"name": "input", "type": "uint256[4]"}
        ],
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "view"
    },
    {
        "name": "estimateVerificationGas",
        "type": "function",
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "pure"
    }
]

COMPLAINT_REGISTRY_ABI = [
    {
        "name": "submitComplaint",
        "type": "function",
        "inputs": [
            {"name": "theoremHash", "type": "bytes32"},
            {"name": "axiomsCommitment", "type": "bytes32"},
            {"name": "circuitVersion", "type": "uint256"},
            {"name": "verified", "type": "bool"},
            {"name": "note", "type": "string"}
        ],
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "nonpayable"
    },
    {
        "name": "complaintCount",
        "type": "function",
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view"
    }
]


VK_HASH_REGISTRY_ABI = [
    {
        "name": "registerVK",
        "type": "function",
        "inputs": [
            {"name": "circuitId", "type": "bytes32"},
            {"name": "version", "type": "uint64"},
            {"name": "vkHash", "type": "bytes32"},
            {"name": "overwrite", "type": "bool"},
        ],
        "outputs": [],
        "stateMutability": "nonpayable",
    },
    {
        "name": "setDeprecated",
        "type": "function",
        "inputs": [
            {"name": "circuitId", "type": "bytes32"},
            {"name": "version", "type": "uint64"},
            {"name": "deprecated", "type": "bool"},
        ],
        "outputs": [],
        "stateMutability": "nonpayable",
    },
    {
        "name": "isRegistered",
        "type": "function",
        "inputs": [
            {"name": "circuitId", "type": "bytes32"},
            {"name": "version", "type": "uint64"},
        ],
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "view",
    },
    {
        "name": "getVK",
        "type": "function",
        "inputs": [
            {"name": "circuitId", "type": "bytes32"},
            {"name": "version", "type": "uint64"},
        ],
        "outputs": [
            {"name": "vkHash", "type": "bytes32"},
            {"name": "deprecated", "type": "bool"},
            {"name": "registeredAt", "type": "uint64"},
        ],
        "stateMutability": "view",
    },
]