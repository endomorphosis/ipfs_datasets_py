"""High-level API for vector store operations.

This module provides convenient functions for common vector store operations,
making it easy to get started with IPLD/IPFS vector storage.
"""

import logging
from typing import List, Dict, Any, Optional, Union

from .base import BaseVectorStore
from .config import UnifiedVectorStoreConfig, create_ipld_config, VectorStoreType
from .schema import EmbeddingResult, SearchResult
from .ipld_vector_store import IPLDVectorStore
from .faiss_store import FAISSVectorStore
from .qdrant_store import QdrantVectorStore
from .manager import VectorStoreManager
from .bridges import create_bridge

logger = logging.getLogger(__name__)


async def create_vector_store(
    store_type: Union[str, VectorStoreType],
    collection_name: str,
    dimension: int = 768,
    distance_metric: str = "cosine",
    **kwargs
) -> BaseVectorStore:
    """Create and initialize a vector store.
    
    Args:
        store_type: Type of store ('ipld', 'faiss', 'qdrant', 'elasticsearch')
        collection_name: Name of the collection
        dimension: Vector dimension
        distance_metric: Distance metric to use
        **kwargs: Additional configuration parameters
        
    Returns:
        Initialized vector store instance
        
    Example:
        ```python
        # Create IPLD vector store
        store = await create_vector_store(
            "ipld",
            "documents",
            dimension=768,
            use_embeddings_router=True,
            use_ipfs_router=True
        )
        
        await store.create_collection()
        ```
    """
    # Normalize store type
    if isinstance(store_type, str):
        store_type = store_type.lower()
        if store_type == "ipld":
            store_type = VectorStoreType.IPLD
        elif store_type == "faiss":
            store_type = VectorStoreType.FAISS
        elif store_type == "qdrant":
            store_type = VectorStoreType.QDRANT
        elif store_type == "elasticsearch":
            store_type = VectorStoreType.ELASTICSEARCH
    
    # Create config
    config = UnifiedVectorStoreConfig(
        store_type=store_type,
        collection_name=collection_name,
        dimension=dimension,
        distance_metric=distance_metric,
        **kwargs
    )
    
    # Create store based on type
    if store_type == VectorStoreType.IPLD or (isinstance(store_type, str) and store_type == "ipld"):
        store = IPLDVectorStore(config)
    elif store_type == VectorStoreType.FAISS or (isinstance(store_type, str) and store_type == "faiss"):
        store = FAISSVectorStore(config)
    elif store_type == VectorStoreType.QDRANT or (isinstance(store_type, str) and store_type == "qdrant"):
        store = QdrantVectorStore(config)
    else:
        from .elasticsearch_store import ElasticsearchVectorStore
        store = ElasticsearchVectorStore(config)
    
    logger.info(f"Created {store_type} vector store for collection '{collection_name}'")
    return store


async def add_texts_to_store(
    store: BaseVectorStore,
    texts: List[str],
    metadata: Optional[List[Dict[str, Any]]] = None,
    collection_name: Optional[str] = None,
    batch_size: int = 100
) -> List[str]:
    """Add texts to a vector store.
    
    If the store has embeddings router enabled, embeddings will be generated
    automatically. Otherwise, this function will raise an error.
    
    Args:
        store: Vector store instance
        texts: List of texts to add
        metadata: Optional metadata for each text
        collection_name: Target collection name
        batch_size: Batch size for adding
        
    Returns:
        List of vector IDs
        
    Example:
        ```python
        store = await create_vector_store("ipld", "docs", use_embeddings_router=True)
        await store.create_collection()
        
        texts = ["Hello world", "IPFS is great"]
        ids = await add_texts_to_store(store, texts)
        ```
    """
    if not texts:
        return []
    
    # Create embedding results
    embeddings = []
    for i, text in enumerate(texts):
        meta = metadata[i] if metadata and i < len(metadata) else {}
        emb = EmbeddingResult(
            chunk_id=None,  # Will be auto-generated
            content=text,
            embedding=None,  # Will be generated by router if available
            metadata=meta
        )
        embeddings.append(emb)
    
    # Add in batches
    all_ids = []
    for i in range(0, len(embeddings), batch_size):
        batch = embeddings[i:i + batch_size]
        ids = await store.add_embeddings(batch, collection_name)
        all_ids.extend(ids)
    
    logger.info(f"Added {len(texts)} texts to store")
    return all_ids


async def search_texts(
    store: BaseVectorStore,
    query: str,
    top_k: int = 10,
    collection_name: Optional[str] = None,
    filter_dict: Optional[Dict[str, Any]] = None
) -> List[SearchResult]:
    """Search for similar texts in a vector store.
    
    If the store has embeddings router enabled, the query embedding will be
    generated automatically.
    
    Args:
        store: Vector store instance
        query: Query text
        top_k: Number of results to return
        collection_name: Collection to search
        filter_dict: Optional metadata filters
        
    Returns:
        List of search results
        
    Example:
        ```python
        results = await search_texts(
            store,
            "What is IPFS?",
            top_k=5
        )
        
        for result in results:
            print(f"Score: {result.score}, Text: {result.content}")
        ```
    """
    # Check if store has router integration
    if hasattr(store, 'router') and store.router and store.router.is_embeddings_available():
        # Generate query embedding
        embeddings = await store.router.generate_embeddings([query])
        query_vector = embeddings[0]
    else:
        raise ValueError(
            "Store does not have embeddings router enabled. "
            "Cannot generate query embedding from text."
        )
    
    # Search
    results = await store.search(
        query_vector,
        top_k=top_k,
        collection_name=collection_name,
        filter_dict=filter_dict
    )
    
    return results


async def migrate_collection(
    source_store: BaseVectorStore,
    target_store: BaseVectorStore,
    collection_name: str,
    target_collection_name: Optional[str] = None,
    batch_size: int = 1000,
    verify: bool = True
) -> int:
    """Migrate a collection between vector stores.
    
    Args:
        source_store: Source vector store
        target_store: Target vector store
        collection_name: Collection to migrate
        target_collection_name: Target collection name (optional)
        batch_size: Batch size for migration
        verify: Whether to verify after migration
        
    Returns:
        Number of vectors migrated
        
    Example:
        ```python
        faiss_store = await create_vector_store("faiss", "docs")
        ipld_store = await create_vector_store("ipld", "docs")
        
        # Migrate from FAISS to IPLD
        count = await migrate_collection(
            faiss_store,
            ipld_store,
            "documents"
        )
        print(f"Migrated {count} vectors")
        ```
    """
    # Create bridge
    bridge = create_bridge(source_store, target_store)
    
    # Migrate
    count = await bridge.migrate_collection(
        collection_name,
        target_collection_name=target_collection_name,
        batch_size=batch_size,
        verify=verify
    )
    
    logger.info(f"Migrated {count} vectors from {source_store.__class__.__name__} to {target_store.__class__.__name__}")
    return count


async def export_collection_to_ipfs(
    store: BaseVectorStore,
    collection_name: Optional[str] = None
) -> Optional[str]:
    """Export a collection to IPFS/IPLD.
    
    Args:
        store: Vector store instance
        collection_name: Collection to export
        
    Returns:
        Root CID of the exported collection, or None if not supported
        
    Example:
        ```python
        store = await create_vector_store("ipld", "docs")
        # ... add data ...
        
        cid = await export_collection_to_ipfs(store)
        print(f"Collection available at: ipfs://{cid}")
        ```
    """
    if hasattr(store, 'export_to_ipld'):
        cid = await store.export_to_ipld(collection_name)
        logger.info(f"Exported collection to IPFS: {cid}")
        return cid
    else:
        logger.warning(f"{store.__class__.__name__} does not support IPLD export")
        return None


async def import_collection_from_ipfs(
    store: BaseVectorStore,
    root_cid: str,
    collection_name: Optional[str] = None
) -> bool:
    """Import a collection from IPFS/IPLD.
    
    Args:
        store: Vector store instance
        root_cid: Root CID to import
        collection_name: Name for the imported collection
        
    Returns:
        True if successful
        
    Example:
        ```python
        store = await create_vector_store("ipld", "docs")
        
        success = await import_collection_from_ipfs(
            store,
            "QmXXX...",
            "imported_docs"
        )
        ```
    """
    if hasattr(store, 'import_from_ipld'):
        success = await store.import_from_ipld(root_cid, collection_name)
        if success:
            logger.info(f"Imported collection from IPFS: {root_cid}")
        return success
    else:
        logger.warning(f"{store.__class__.__name__} does not support IPLD import")
        return False


def create_manager() -> VectorStoreManager:
    """Create a vector store manager.
    
    Returns:
        VectorStoreManager instance
        
    Example:
        ```python
        manager = create_manager()
        
        # Register stores
        manager.register_store("ipld", create_ipld_config("docs", 768))
        manager.register_store("faiss", create_faiss_config("docs", 768))
        
        # Use stores
        store = await manager.get_store("ipld")
        ```
    """
    return VectorStoreManager()


__all__ = [
    'create_vector_store',
    'add_texts_to_store',
    'search_texts',
    'migrate_collection',
    'export_collection_to_ipfs',
    'import_collection_from_ipfs',
    'create_manager',
]
