#!/usr/bin/env python3
"""
Generate workflow fix proposals based on failure analysis.

This script takes the failure analysis and generates specific fix proposals
including code changes, configuration updates, and PR content.
"""

import argparse
import json
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional


class WorkflowFixGenerator:
    """Generates fix proposals for workflow failures."""
    
    def __init__(self, analysis: Dict[str, Any], workflow_name: str):
        self.analysis = analysis
        self.workflow_name = workflow_name
        self.proposal: Dict[str, Any] = {}
    
    def generate(self) -> Dict[str, Any]:
        """Generate comprehensive fix proposal."""
        print(f"ðŸ”§ Generating fix proposal for {self.workflow_name}...")
        
        fix_type = self.analysis.get('fix_type', 'manual')
        error_type = self.analysis.get('error_type', 'Unknown')
        
        # Generate branch name
        branch_name = self._generate_branch_name(fix_type)
        
        # Generate PR title and description
        pr_title = self._generate_pr_title(error_type, fix_type)
        pr_description = self._generate_pr_description()
        
        # Generate specific fixes
        fixes = self._generate_fixes(fix_type)
        
        # Compile proposal
        self.proposal = {
            'branch_name': branch_name,
            'pr_title': pr_title,
            'pr_description': pr_description,
            'fix_type': fix_type,
            'error_type': error_type,
            'fixes': fixes,
            'analysis_summary': {
                'run_id': self.analysis.get('run_id'),
                'workflow_name': self.workflow_name,
                'confidence': self.analysis.get('fix_confidence', 50),
                'root_cause': self.analysis.get('root_cause'),
            },
            'labels': self._generate_labels(fix_type),
            'reviewers': ['github-copilot'],
            'auto_merge': False,  # Require review
        }
        
        return self.proposal
    
    def _generate_branch_name(self, fix_type: str) -> str:
        """Generate a descriptive branch name."""
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        safe_workflow = re.sub(r'[^a-z0-9-]', '-', self.workflow_name.lower())
        safe_fix_type = re.sub(r'[^a-z0-9-]', '-', fix_type.lower())
        
        return f"autofix/{safe_workflow}/{safe_fix_type}/{timestamp}"
    
    def _generate_pr_title(self, error_type: str, fix_type: str) -> str:
        """Generate PR title."""
        return f"fix: Auto-fix {error_type} in {self.workflow_name}"
    
    def _generate_pr_description(self) -> str:
        """Generate detailed PR description."""
        description = f"""# Automated Workflow Fix

## Summary
This PR was automatically generated to fix a failure in the **{self.workflow_name}** workflow.

## Failure Details
- **Run ID**: {self.analysis.get('run_id')}
- **Error Type**: {self.analysis.get('error_type')}
- **Root Cause**: {self.analysis.get('root_cause')}
- **Fix Confidence**: {self.analysis.get('fix_confidence')}%

## Analysis
{self._format_analysis_section()}

## Proposed Fix
{self._format_fixes_section()}

## Recommendations
{self._format_recommendations_section()}

## Affected Files
{self._format_affected_files_section()}

---

### ðŸ¤– About This PR
- **Generated by**: GitHub Actions Workflow Auto-Fix System
- **Reviewed by**: GitHub Copilot (pending)
- **Type**: Automated Fix
- **Requires Review**: Yes

### Next Steps
1. Review the proposed changes
2. GitHub Copilot will analyze the fix
3. Run tests to verify the fix resolves the issue
4. Merge if all checks pass

### Related
- Workflow Run: https://github.com/${{{{ github.repository }}}}/actions/runs/{self.analysis.get('run_id')}
- Workflow File: `.github/workflows/{self._get_workflow_filename()}`
"""
        
        return description
    
    def _format_analysis_section(self) -> str:
        """Format the analysis section of the PR description."""
        patterns = self.analysis.get('patterns_found', [])
        
        if not patterns:
            return "No specific patterns identified."
        
        return "\n".join([f"- {pattern}" for pattern in patterns])
    
    def _format_fixes_section(self) -> str:
        """Format the fixes section of the PR description."""
        fixes = self.proposal.get('fixes', [])
        
        if not fixes:
            return "Manual review required."
        
        sections = []
        for fix in fixes:
            sections.append(f"### {fix['description']}\n")
            sections.append(f"**File**: `{fix['file']}`\n")
            sections.append(f"**Action**: {fix['action']}\n")
            
            if fix.get('changes'):
                sections.append("\n```yaml\n" + fix['changes'] + "\n```\n")
        
        return "\n".join(sections)
    
    def _format_recommendations_section(self) -> str:
        """Format recommendations section."""
        recommendations = self.analysis.get('recommendations', [])
        
        if not recommendations:
            return "No specific recommendations."
        
        return "\n".join([f"- {rec}" for rec in recommendations])
    
    def _format_affected_files_section(self) -> str:
        """Format affected files section."""
        files = self.analysis.get('affected_files', [])
        
        if not files:
            return "No specific files identified."
        
        return "\n".join([f"- `{file}`" for file in files])
    
    def _get_workflow_filename(self) -> str:
        """Get workflow filename from workflow name."""
        # Convert workflow name to likely filename
        filename = re.sub(r'[^a-z0-9-]', '-', self.workflow_name.lower())
        return f"{filename}.yml"
    
    def _generate_fixes(self, fix_type: str) -> List[Dict[str, Any]]:
        """Generate specific fix changes based on fix type."""
        fixes = []
        
        if fix_type == 'add_dependency':
            fixes.extend(self._fix_add_dependency())
        
        elif fix_type == 'increase_timeout':
            fixes.extend(self._fix_increase_timeout())
        
        elif fix_type == 'fix_permissions':
            fixes.extend(self._fix_permissions())
        
        elif fix_type == 'add_retry':
            fixes.extend(self._fix_add_retry())
        
        elif fix_type == 'fix_docker':
            fixes.extend(self._fix_docker())
        
        elif fix_type == 'increase_resources':
            fixes.extend(self._fix_increase_resources())
        
        elif fix_type == 'add_env_variable':
            fixes.extend(self._fix_add_env_variable())
        
        else:
            # Generic fix suggestion
            fixes.append({
                'file': f'.github/workflows/{self._get_workflow_filename()}',
                'action': 'review_required',
                'description': 'Manual review and fix required',
                'changes': None,
            })
        
        return fixes
    
    def _fix_add_dependency(self) -> List[Dict[str, Any]]:
        """Generate fix for missing dependencies."""
        fixes = []
        
        # Extract package name from analysis
        root_cause = self.analysis
        captured_values = root_cause.get('captured_values', [])
        
        if captured_values and len(captured_values) > 0:
            # Get the package name - it might have underscores or hyphens
            package = captured_values[0]
            # Convert underscores to hyphens for pip package names
            pip_package = package.replace('_', '-')
            
            # Fix for workflow
            workflow_fix = {
                'file': f'.github/workflows/{self._get_workflow_filename()}',
                'action': 'add_install_step',
                'description': f'Add pip install step for {pip_package}',
                'changes': f"""- name: Install missing dependency
  run: |
    pip install {pip_package}""",
            }
            fixes.append(workflow_fix)
            
            # Fix for requirements.txt
            requirements_fix = {
                'file': 'requirements.txt',
                'action': 'add_line',
                'description': f'Add {pip_package} to requirements.txt',
                'changes': pip_package,
            }
            fixes.append(requirements_fix)
        
        return fixes
    
    def _fix_increase_timeout(self) -> List[Dict[str, Any]]:
        """Generate fix for timeout issues."""
        return [{
            'file': f'.github/workflows/{self._get_workflow_filename()}',
            'action': 'add_timeout',
            'description': 'Increase timeout for long-running step',
            'changes': """timeout-minutes: 30  # Increased from default""",
        }]
    
    def _fix_permissions(self) -> List[Dict[str, Any]]:
        """Generate fix for permission errors."""
        return [{
            'file': f'.github/workflows/{self._get_workflow_filename()}',
            'action': 'add_permissions',
            'description': 'Add required permissions to workflow',
            'changes': """permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read""",
        }]
    
    def _fix_add_retry(self) -> List[Dict[str, Any]]:
        """Generate fix for network errors."""
        return [{
            'file': f'.github/workflows/{self._get_workflow_filename()}',
            'action': 'add_retry_action',
            'description': 'Add retry logic for network operations',
            'changes': """- name: Retry network operation
  uses: nick-invision/retry@v2
  with:
    timeout_minutes: 10
    max_attempts: 3
    retry_on: error
    command: |
      # Your network command here""",
        }]
    
    def _fix_docker(self) -> List[Dict[str, Any]]:
        """Generate fix for Docker errors."""
        return [{
            'file': f'.github/workflows/{self._get_workflow_filename()}',
            'action': 'add_docker_setup',
            'description': 'Add Docker setup steps',
            'changes': """- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v3

- name: Log in to Container Registry
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}""",
        }]
    
    def _fix_increase_resources(self) -> List[Dict[str, Any]]:
        """Generate fix for resource exhaustion."""
        return [{
            'file': f'.github/workflows/{self._get_workflow_filename()}',
            'action': 'change_runner',
            'description': 'Use a larger runner with more resources',
            'changes': """runs-on: ubuntu-latest-4-cores  # Increased from ubuntu-latest""",
        }]
    
    def _fix_add_env_variable(self) -> List[Dict[str, Any]]:
        """Generate fix for missing environment variables."""
        return [{
            'file': f'.github/workflows/{self._get_workflow_filename()}',
            'action': 'add_env',
            'description': 'Add missing environment variable',
            'changes': """env:
  # Add your required environment variable here
  REQUIRED_VAR: ${{ secrets.REQUIRED_VAR }}""",
        }]
    
    def _generate_labels(self, fix_type: str) -> List[str]:
        """Generate appropriate labels for the PR."""
        labels = [
            'automated-fix',
            'workflow-fix',
            'copilot-ready',
        ]
        
        # Add fix-type specific labels
        if fix_type == 'add_dependency':
            labels.append('dependencies')
        elif fix_type in ['fix_permissions', 'add_env_variable']:
            labels.append('configuration')
        elif fix_type == 'fix_docker':
            labels.append('docker')
        elif fix_type in ['fix_test', 'fix_syntax']:
            labels.append('bug')
        
        return labels


def main():
    parser = argparse.ArgumentParser(
        description='Generate workflow fix proposals'
    )
    parser.add_argument('--analysis', required=True, help='Path to failure analysis JSON')
    parser.add_argument('--workflow-name', required=True, help='Workflow name')
    parser.add_argument('--output', required=True, help='Output file for fix proposal')
    
    args = parser.parse_args()
    
    # Load analysis
    with open(args.analysis, 'r') as f:
        analysis = json.load(f)
    
    # Generate fix proposal
    generator = WorkflowFixGenerator(
        analysis=analysis,
        workflow_name=args.workflow_name,
    )
    
    proposal = generator.generate()
    
    # Write proposal
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        json.dump(proposal, f, indent=2)
    
    print(f"âœ… Fix proposal generated: {output_path}")
    print(f"   Branch: {proposal['branch_name']}")
    print(f"   Title: {proposal['pr_title']}")
    print(f"   Fixes: {len(proposal['fixes'])} proposed")


if __name__ == '__main__':
    main()
